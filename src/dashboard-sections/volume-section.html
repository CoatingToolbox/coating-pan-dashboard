<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/iron-selector/iron-selector.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/polymer/lib/mixins/gesture-event-listeners.html">
<link rel="import" href="../redux-mixin.html">
<link rel="import" href="../elements/unit-input.html">
<link rel="import" href="../elements/coating-pan-graphic.html">
<link rel="import" href="../elements/d3-import.html">
<link rel="import" href="../elements/donut-card.html">
<link rel="import" href="../elements/volume-card.html">
<link rel="import" href="section-styles.html">

<dom-module id="volume-section">
  <template>
    <style include='section-styles'>
      :host {
        display: flex;
        flex-direction: column;
      }
      #volume-card-container {
        display: flex;
      }
      #second-section {
        display: flex;
        margin-bottom: 16px;
        align-items: flex-start;
      } 
      #info-container {
        display: flex;
        flex-direction: column;
        margin-left: 16px;
        max-width: calc(33.33% - 8px);
        flex-grow: 1;
      }
      .chart-card {
        flex-grow: 1;
      }
      #chart-container {
        margin: 0px 16px;
      }
      .card + .card {
        margin-top: var(--card-margin);
      }
      volume-card {
        max-width: calc(33.33% - 10.66px);
      }
      volume-card + volume-card{
        margin-left: 16px;
      }
      .volume-selector {
        display: flex;
        align-self: flex-end;
        margin: 16px 24px;
      }
      .volume-tab {
        padding: 8px 16px;
        color: var(--text-secondary-color);
        @apply --paper-font-body2;
      }
      .volume-tab.iron-selected {
        color: white;
        background-color: var(--app-dark-color);
        border-radius: 4px;
        font-weigth: 500;
      }
    </style>
    
    <style>
      #chart {
          height: 100%;
          min-height: 300px;
          width: 100%;
          max-height: 350px;
          font-family: inherit;
          font-size: 14px;
          font-weight: 400;
          letter-spacing: 0.011em;
          line-height: 20px;
          fill: var(--text-secondary-color);
      }
      .title {
          text-anchor: middle;
      }
      .y.title {
          transform: rotate(-90deg);
      }
      .axis text {
          font-size: 12px;
          font-weight: 200;
          fill: var(--text-secondary-color);
      }
      .axis line,
      .axis .domain {
          stroke: var(--text-secondary-color);
      }
      .line {
        fill: none;
        stroke: var(--app-light-color);
        stroke-width: 3px;
        stroke-linecap: 'round';
      }
      .height.line {
        stroke-dasharray: 10;
        stroke: var(--divider-color);
      }
      .area {
          fill: var(--divider-color);
          fill-opacity: 0.1;
      }
      .working-volume.line {
          stroke: var(--app-primary-color);
      }
      .working-volume.area {
          fill: var(--text-primary-color);
      }
      circle {
          stroke: var(--app-primary-color);
          stroke-width: 4px;
          fill: white;
      }
    </style>
    
    <div class='section-title'>Coating Pan Volume</div>
    <iron-selector id='volume-card-container' selected='{{volumeSelected}}' attr-for-selected='type'>
      <volume-card label='Min Working' type='min'></volume-card>
      <volume-card label='Max Working' type='max'></volume-card>
      <volume-card label='Brim' type='brim'></volume-card>
    </iron-selector>
    
    
    <div class='section-title'>Coating Pan Fill Height</div>
    
    <div id='second-section'>
      
      <div class='card chart-card'>
          <div id='chart-container'>
            <svg id='chart'>
              <g class='chart'>
                  <g class='x axis'></g>
                  <g class='y axis'></g>
                  <text class='x title'>Product Fill Height (inches)</text>
                  <text class='y title'>Volume (liters)</text>
                  <path class='total-volume area'></path>
                  <path class='total-volume line'></path>
                  <path class='height line'></path>
                  <path class='working-volume area'></path>
                  <path class='working-volume line'></path>
                  <g class='volume-circles'></g>
              </g>
            </svg>
          </div>
          <iron-selector selected='{{volumeSelected}}' attr-for-selected='volume'>
            <unit-input 
                volume='min'
                value='[[pan.minFillHeight]]' 
                type='length'
                selected-units='{{lengthUnits}}' 
                no-input 
                title='Min Fill Height' 
                details='Baffle height or 70% of brim height.'>
            </unit-input>
            <unit-input 
                volume='max'
                value='[[pan.maxFillHeight]]' 
                type='length'
                selected-units='{{lengthUnits}}' 
                no-input 
                title='Max Fill Height' 
                details='1" from brim opening.'>
            </unit-input>
            <unit-input 
                volume='brim'
                value='[[pan.brimHeight]]' 
                type='length'
                selected-units='{{lengthUnits}}' 
                no-input 
                title='Brim Height' 
                details='The overfilled limit.'>
            </unit-input>
        </iron-selector>
        </div>
      
      <div id='info-container'>
        
        <div class='card text'>
          <div class='title'>Fill Height</div>
          <div class='description'>
            The Fill Height of the coating pan is used to determine the range of volumes. The brim height sets the maxiumu volume
            of product before material falls out of the pan. The max working volume is estimated as 1" from the brim height. This allows
            room for the tablets to tumble without falling out. The min working volume is estimated based on the baffle height. It is recommend
            the product fill be higher than the baffle.
          </div>
        </div>
       
        <div class='card text highlight'>
          <div class='title'>Batch Weight</div>
          <div class='description'>
            To convert coating pan volumes to batch weight checkout the 
            batch size section. In this section provide a bulk density and you 
            can see the recommend range of batch weight and more.
          </div>
          <paper-button>Batch Size</paper-button>
        </div>
        
      </div> 
      
      
    </div>  
    
  </template>

  <script>
    class VolumeSection extends ReduxMixin(Polymer.GestureEventListeners(Polymer.Element)) {
      static get is() { return 'volume-section'; }
      
      connectedCallback() {
          super.connectedCallback();
          window.addEventListener('resize', () => this._setChartDimensions());
          this._setChartDimensions();
      }
      
      _setChartDimensions() {
          if(!this.$.chart) {
              return;
          }
          
          window.requestAnimationFrame(() => {
              this.chartHeight = this.$.chart.clientHeight - this.margin.top - this.margin.bottom;
              this.chartWidth = this.$.chart.clientWidth - this.margin.left - this.margin.right;
          });
      }
      
      static get properties() {
        return {
          pan: {type: Object, statePath: 'pan'},
          volumeUnits: {type: String, value: "l"},
          lengthUnits: {type: String, value: 'in'},
          volumeSelected: {type: String, value: "max"},
          chart: {type: Object},
          margin: {type: Object, value: function() {
              return {top: 20, right: 20, bottom: 50, left: 50};
          }},
          chartHeight: {type: Number},
          chartWidth: {type: Number},
          xScale: {type: Object, computed: '_computeXScale(chartWidth, pan.brimHeight)'},
          yScale: {type: Object, computed: '_computeYScale(chartHeight, pan.brimVolume)'},
          d3Line: {type: Object, computed: '_computeD3Line(xScale, yScale)'},
          d3Area: {type: Object, computed: '_computeD3Area(xScale, yScale, chartHeight)'}
        };
      }
      
      _computeXScale(chartWidth, brim) {
          let max = this._convertToInches(brim) * 1.1;
          return d3.scaleLinear().range([0, chartWidth]).domain([0, max]).nice();
      }
      _computeYScale(chartHeight, brim) {
          let max = this._convertToLiters(brim) * 1.1;
          return d3.scaleLinear().range([chartHeight, 0]).domain([0, max]).nice();
      }
      _computeD3Line(xScale, yScale) {
          return d3.line()
              .x(function(d) { return xScale(d.x); })
              .y(function(d) { return yScale(d.y); })
              .curve(d3.curveNatural);
      }
      _computeD3Area(xScale, yScale, height) {
          return d3.area()
                   .x(function(d) { return xScale(d.x); })
                   .y0(height)
                   .y1(function(d) { return yScale(d.y); }); 
      }
      static get observers() {
          return [
              '_initChart(margin, chartHeight, chartWidth)',
              '_updateAxis(xScale, yScale, chart)',
              '_updateDashedLine(pan, chart, d3Line, d3Area)',
              '_updateHeightLine(pan, volumeSelected, chart, d3Line, d3Area)',
              '_updateSolidLine(pan, volumeSelected, chart, d3Line, d3Area)',
              '_updateVolumePoints(pan, volumeSelected, chart, xScale, yScale)',
          ];
      }
      
      _initChart(margin, height, width) {
          if(!margin || !height || !width) {
              return;
          }
          let chart = d3.select(this.$.chart)
                              .attr("width", width + margin.left + margin.right)
                              .attr("height", height + margin.top + margin.bottom)
                          .select(".chart")
                              .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                                          
          chart.select(".x.axis").attr("transform", "translate(0," + height + ")");
          chart.select(".x.title").attr("transform", "translate(" + (width/2) + " ," + (height + margin.top + 25) + ")");
          chart.select(".y.title").attr("y", 0 - margin.left).attr("x",0 - (height / 2)).attr("dy", "1em");      
          
          // set the chart object
          this.chart = chart;
      }
      _updateAxis(xScale, yScale, chart) {
          if(!xScale || !yScale || !chart) {
              return;
          }
          chart.select(".x.axis").call(d3.axisBottom(xScale));
          chart.select(".y.axis").call(d3.axisLeft(yScale));  
      }
      _updateDashedLine(pan, chart, line, area) {
          if(!pan || !chart || !line || !area) {
              return;
          }
          
          // create a new coating pan object to make changes to
          let p = Object.assign(new CoatingPan(), pan);
          
          // initiate an empty array to store values in for loop
          let vals = [];
          let step = pan.brimVolume / 25;
          
          // loop through different volumes and store the volume and height values
          for(var i=0; i < pan.brimVolume; i = i + step) {
              p.fillVolume = i;
              vals.push({y: this._convertToLiters(p.fillVolume), x: this._convertToInches(p.fillHeight)});
          }
          // finally store the max values 
          vals.push({y: this._convertToLiters(pan.brimVolume), x: this._convertToInches(pan.brimHeight)});
          
          // Add the line
          let lines = chart.select('.total-volume.line').data([vals]);
          lines.enter()
              .merge(lines)
                  .attr("d", line);  
          lines.exit().remove();
                          
          // Add the area
          let areas = chart.select('.total-volume.area').data([vals]);
          areas.enter()
              .merge(areas)
                  .attr("d", area);  
          areas.exit().remove();
      }
      _updateHeightLine(pan, volumeSelected, chart, line, area) {
          if(!pan || !volumeSelected || !chart || !line || !area) {
              return;
          }
          
          // initiate an empty array to store values in for loop
          let vals = [];
          
          switch(volumeSelected) {
            case 'min': 
              vals.push({y: 0, x: this._convertToInches(pan.minFillHeight)});
              vals.push({y: this._convertToLiters(pan.minFillVolume), x: this._convertToInches(pan.minFillHeight)});
              break;
            case 'max':
              vals.push({y: 0, x: this._convertToInches(pan.maxFillHeight)});
              vals.push({y: this._convertToLiters(pan.maxFillVolume), x: this._convertToInches(pan.maxFillHeight)});
              break;
            case 'brim':
              vals.push({y: 0, x: this._convertToInches(pan.brimHeight)});
              vals.push({y: this._convertToLiters(pan.brimVolume), x: this._convertToInches(pan.brimHeight)});
              break;
            default: 
              vals.push({y: 0, x: 0});
              break;
          }
          
          // Add the line
          let lines = chart.select('.height.line').data([vals]);
          lines.enter()
              .merge(lines)
                  .attr("d", line);  
          lines.exit().remove();
      }
      _updateSolidLine(pan, volumeSelected, chart, line, area) {
          if(!pan || !volumeSelected || !chart || !line || !area) {
              return;
          }
          
          // create a new coating pan object to make changes to
          let p = Object.assign(new CoatingPan(), pan);
          
          let limitVolume, limitHeight, limitLowVolume; 
          switch(volumeSelected) {
            case 'min': 
              limitVolume = pan.minFillVolume;
              limitHeight = pan.minFillHeight;
              limitLowVolume = 0;
              break;
            case 'max':
              limitVolume = pan.maxFillVolume;
              limitHeight = pan.maxFillHeight;
              limitLowVolume = 0;
              break;
            case 'brim':
              limitVolume = pan.brimVolume;
              limitHeight = pan.brimHeight;
              limitLowVolume = 0;
              break;
            case 'range':
              limitVolume = pan.maxFillVolume;
              limitHeight = pan.maxFillHeight;
              limitLowVolume = pan.minFillVolume;
              break;
            default: 
              limitLowVolume = 0;
              limitVolume = 0;
              limitHeight = 0;
              break;
          }
          
          // initiate an empty array to store values in for loop
          let vals = [];
          let step = (limitVolume - limitLowVolume) / 25;
          
          // loop through different volumes and store the volume and height values
          for(var i=limitLowVolume; i < limitVolume; i = i + step) {
              p.fillVolume = i;
              vals.push({y: this._convertToLiters(p.fillVolume), x: this._convertToInches(p.fillHeight)});
          }
          // finally store the max values 
          vals.push({y: this._convertToLiters(limitVolume), x: this._convertToInches(limitHeight)});
          
          // Add the line
          let lines = chart.select('.working-volume.line').data([vals]);
          lines.enter()
              .merge(lines)
                  .attr("d", line);  
          lines.exit().remove();
                          
          // Add the area
          let areas = chart.select('.working-volume.area').data([vals]);
          areas.enter()
              .merge(areas)
                  .attr("d", area);  
          areas.exit().remove();
      }
      _updateVolumePoints(pan, volumeSelected, chart, xScale, yScale) {
          if(!pan || !volumeSelected || !chart || !xScale || !yScale) {
              return;
          }
          
          let vals = [];
          
          switch(volumeSelected) {
            case 'min': 
              vals.push({y: this._convertToLiters(pan.minFillVolume), x: this._convertToInches(pan.minFillHeight)});
              break;
            case 'max':
              vals.push({y: this._convertToLiters(pan.maxFillVolume), x: this._convertToInches(pan.maxFillHeight)});
              break;
            case 'brim':
              vals.push({y: this._convertToLiters(pan.brimVolume), x: this._convertToInches(pan.brimHeight)});
              break;
            case 'range':
              vals.push({y: this._convertToLiters(pan.minFillVolume), x: this._convertToInches(pan.minFillHeight)});
              vals.push({y: this._convertToLiters(pan.maxFillVolume), x: this._convertToInches(pan.maxFillHeight)});
              break;
            default: 
              vals.push({y: 0, x: 0});
              break;
          }
          
          // Add the dots
          let circles = chart.select('.volume-circles').selectAll('circle').data(vals);
          
          circles.enter()
                  .append('circle')
                      .attr('r', 7)
                  .merge(circles)
                    .attr('cx', function(d) { return xScale(d.x);})
                    .attr('cy', function(d) { return yScale(d.y);});
          
          circles.exit().remove();
      }
      
      _convertToInches(val) {
          return val * 39.37;
      }
      _convertToLiters(val) {
          return (val / 0.001) ;
      }
      _convertToLitersString(val) {
          return this._convertToLiters(val).toFixed(1);
      }
    }

    window.customElements.define(VolumeSection.is, VolumeSection);
  </script>
</dom-module>