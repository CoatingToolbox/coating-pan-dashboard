<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/iron-selector/iron-selector.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/polymer/lib/mixins/gesture-event-listeners.html">
<link rel="import" href="../redux-mixin.html">
<link rel="import" href="../elements/unit-input.html">
<link rel="import" href="../elements/coating-pan-graphic.html">
<link rel="import" href="../elements/d3-import.html">
<link rel="import" href="../elements/donut-card.html">
<link rel="import" href="section-styles.html">

<dom-module id="volume-section">
  <template>
    <style include='section-styles'>

      :host {
        display: flex;
        flex-direction: column;
      }
      #chart {
          height: 100%;
          min-height: 300px;
          width: 100%;
          max-height: 350px;
          font-family: inherit;
          font-size: 14px;
          font-weight: 400;
          letter-spacing: 0.011em;
          line-height: 20px;
          fill: var(--text-secondary-color);
      }
      .title {
          text-anchor: middle;
      }
      .y.title {
          transform: rotate(-90deg);
      }
      .axis text {
          font-size: 12px;
          font-weight: 200;
          fill: var(--text-secondary-color);
      }
      .axis line,
      .axis .domain {
          stroke: var(--text-secondary-color);
      }
      .line {
        fill: none;
        stroke: var(--app-light-color);
        stroke-width: 3px;
        stroke-linecap: 'round';
      }
      .height.line {
        stroke-dasharray: 10;
        stroke: var(--divider-color);
      }
      .area {
          fill: var(--app-light-color);
          fill-opacity: 0.1;
      }
      .working-volume.line {
          stroke: var(--app-primary-color);
      }
      .working-volume.area {
          fill: var(--app-primary-color);
      }
      circle {
          stroke: var(--app-primary-color);
          stroke-width: 4px;
          fill: white;
      }
      .card {
        flex-grow: 1;
      }
      
    </style>
    
    <style>
      .volume-selector {
        display: flex;
      }
      .volume {
        padding: 16px;
        color: var(--text-secondary-color);
        @apply --paper-font-body2;
      }
      .volume.iron-selected {
        color: var(--app-accent-color);
        font-weigth: 500;
      }
      .card + .card {
        margin-top: var(--card-margin);
      }
      .horizontal {
        display: flex;
        margin-bottom: 16px;
      }
      donut-card {
        max-width: calc(33.3% - 44px);
      }
      donut-card + donut-card {
        margin-left: 16px;
      }
      .flex {
        flex-grow: 1;
      }
      .chart-container {
        margin: 16px;
      }
    </style>
    
    <iron-selector class='horizontal' selected='{{volumeSelected}}' attr-for-selected='type'>
      <donut-card label='Brim' type='brim'></donut-card>
      <donut-card label='Max Working' type='max'></donut-card>
      <donut-card label='Min Working' type='min'></donut-card>
    </iron-selector>
        
    <div class='card'>
      <div class='horizontal'>
        <div class='title flex'>Coating Pan Volume</div>
      <iron-selector class='volume-selector' selected='{{volumeSelected}}' attr-for-selected='volume'>
        <div class='volume' volume='range'>Range</div>
        <div class='volume' volume='brim'>Brim</div>
        <div class='volume' volume='max'>Max</div>
        <div class='volume' volume='min'>Min</div>
      </iron-selector>
      </div>
      <div class='chart-container'>
        <svg id='chart'>
          <g class='chart'>
              <g class='x axis'></g>
              <g class='y axis'></g>
              <text class='x title'>Product Volume (liters)</text>
              <text class='y title'>Fill Height (inches)</text>
              <path class='total-volume area'></path>
              <path class='total-volume line'></path>
              <path class='height line'></path>
              <path class='working-volume area'></path>
              <path class='working-volume line'></path>
              <g class='volume-circles'></g>
          </g>
        </svg>
      </div>
    </div>  
      
    
  </template>

  <script>
    class VolumeSection extends ReduxMixin(Polymer.GestureEventListeners(Polymer.Element)) {
      static get is() { return 'volume-section'; }
      
      connectedCallback() {
          super.connectedCallback();
          window.addEventListener('resize', () => this._setChartDimensions());
          this._setChartDimensions();
      }
      
      _setChartDimensions() {
          if(!this.$.chart) {
              return;
          }
          
          window.requestAnimationFrame(() => {
              this.chartHeight = this.$.chart.clientHeight - this.margin.top - this.margin.bottom;
              this.chartWidth = this.$.chart.clientWidth - this.margin.left - this.margin.right;
          });
      }
      
      static get properties() {
        return {
          pan: {type: Object, statePath: 'pan'},
          volumeUnits: {type: String, value: "l"},
          volumeSelected: {type: String, value: "range"},
          chart: {type: Object},
          margin: {type: Object, value: function() {
              return {top: 20, right: 20, bottom: 50, left: 50};
          }},
          chartHeight: {type: Number},
          chartWidth: {type: Number},
          xScale: {type: Object, computed: '_computeXScale(chartWidth, pan.brimVolume)'},
          yScale: {type: Object, computed: '_computeYScale(chartHeight, pan.brimHeight)'},
          d3Line: {type: Object, computed: '_computeD3Line(xScale, yScale)'},
          d3Area: {type: Object, computed: '_computeD3Area(xScale, yScale, chartHeight)'}
        };
      }
      
      _computeXScale(chartWidth, brimVolume) {
          let max = this._convertToLiters(brimVolume) * 1.1;
          return d3.scaleLinear().range([0, chartWidth]).domain([0, max]).nice();
      }
      _computeYScale(chartHeight, brimHeight) {
          let max = this._convertToInches(brimHeight) * 1.1;
          return d3.scaleLinear().range([chartHeight, 0]).domain([0, max]).nice();
      }
      _computeD3Line(xScale, yScale) {
          return d3.line()
              .x(function(d) { return xScale(d.x); })
              .y(function(d) { return yScale(d.y); })
              .curve(d3.curveNatural);
      }
      _computeD3Area(xScale, yScale, height) {
          return d3.area()
                   .x(function(d) { return xScale(d.x); })
                   .y0(height)
                   .y1(function(d) { return yScale(d.y); }); 
      }
      static get observers() {
          return [
              '_initChart(margin, chartHeight, chartWidth)',
              '_updateAxis(xScale, yScale, chart)',
              '_updateDashedLine(pan, chart, d3Line, d3Area)',
              '_updateHeightLine(pan, volumeSelected, chart, d3Line, d3Area)',
              '_updateSolidLine(pan, volumeSelected, chart, d3Line, d3Area)',
              '_updateVolumePoints(pan, volumeSelected, chart, xScale, yScale)',
          ];
      }
      
      _initChart(margin, height, width) {
          if(!margin || !height || !width) {
              return;
          }
          let chart = d3.select(this.$.chart)
                              .attr("width", width + margin.left + margin.right)
                              .attr("height", height + margin.top + margin.bottom)
                          .select(".chart")
                              .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                                          
          chart.select(".x.axis").attr("transform", "translate(0," + height + ")");
          chart.select(".x.title").attr("transform", "translate(" + (width/2) + " ," + (height + margin.top + 25) + ")");
          chart.select(".y.title").attr("y", 0 - margin.left).attr("x",0 - (height / 2)).attr("dy", "1em");      
          
          // set the chart object
          this.chart = chart;
      }
      _updateAxis(xScale, yScale, chart) {
          if(!xScale || !yScale || !chart) {
              return;
          }
          chart.select(".x.axis").call(d3.axisBottom(xScale));
          chart.select(".y.axis").call(d3.axisLeft(yScale));  
      }
      _updateDashedLine(pan, chart, line, area) {
          if(!pan || !chart || !line || !area) {
              return;
          }
          
          // create a new coating pan object to make changes to
          let p = Object.assign(new CoatingPan(), pan);
          
          // initiate an empty array to store values in for loop
          let vals = [];
          let step = pan.brimVolume / 25;
          
          // loop through different volumes and store the volume and height values
          for(var i=0; i < pan.brimVolume; i = i + step) {
              p.fillVolume = i;
              vals.push({x: this._convertToLiters(p.fillVolume), y: this._convertToInches(p.fillHeight)});
          }
          // finally store the max values 
          vals.push({x: this._convertToLiters(pan.brimVolume), y: this._convertToInches(pan.brimHeight)});
          
          // Add the line
          let lines = chart.select('.total-volume.line').data([vals]);
          lines.enter()
              .merge(lines)
                  .attr("d", line);  
          lines.exit().remove();
                          
          // Add the area
          let areas = chart.select('.total-volume.area').data([vals]);
          areas.enter()
              .merge(areas)
                  .attr("d", area);  
          areas.exit().remove();
      }
      _updateHeightLine(pan, volumeSelected, chart, line, area) {
          if(!pan || !volumeSelected || !chart || !line || !area) {
              return;
          }
          
          // initiate an empty array to store values in for loop
          let vals = [];
          
          switch(volumeSelected) {
            case 'min': 
              vals.push({x: 0, y: this._convertToInches(pan.minFillHeight)});
              vals.push({x: this._convertToLiters(pan.minFillVolume), y: this._convertToInches(pan.minFillHeight)});
              break;
            case 'max':
              vals.push({x: 0, y: this._convertToInches(pan.maxFillHeight)});
              vals.push({x: this._convertToLiters(pan.maxFillVolume), y: this._convertToInches(pan.maxFillHeight)});
              break;
            case 'brim':
              vals.push({x: 0, y: this._convertToInches(pan.brimHeight)});
              vals.push({x: this._convertToLiters(pan.brimVolume), y: this._convertToInches(pan.brimHeight)});
              break;
            default: 
              vals.push({x: 0, y: 0});
              break;
          }
          
          // Add the line
          let lines = chart.select('.height.line').data([vals]);
          lines.enter()
              .merge(lines)
                  .attr("d", line);  
          lines.exit().remove();
      }
      _updateSolidLine(pan, volumeSelected, chart, line, area) {
          if(!pan || !volumeSelected || !chart || !line || !area) {
              return;
          }
          
          // create a new coating pan object to make changes to
          let p = Object.assign(new CoatingPan(), pan);
          
          let limitVolume, limitHeight, limitLowVolume; 
          switch(volumeSelected) {
            case 'min': 
              limitVolume = pan.minFillVolume;
              limitHeight = pan.minFillHeight;
              limitLowVolume = 0;
              break;
            case 'max':
              limitVolume = pan.maxFillVolume;
              limitHeight = pan.maxFillHeight;
              limitLowVolume = 0;
              break;
            case 'brim':
              limitVolume = pan.brimVolume;
              limitHeight = pan.brimHeight;
              limitLowVolume = 0;
              break;
            case 'range':
              limitVolume = pan.maxFillVolume;
              limitHeight = pan.maxFillHeight;
              limitLowVolume = pan.minFillVolume;
              break;
            default: 
              limitLowVolume = 0;
              limitVolume = 0;
              limitHeight = 0;
              break;
          }
          
          // initiate an empty array to store values in for loop
          let vals = [];
          let step = (limitVolume - limitLowVolume) / 25;
          
          // loop through different volumes and store the volume and height values
          for(var i=limitLowVolume; i < limitVolume; i = i + step) {
              p.fillVolume = i;
              vals.push({x: this._convertToLiters(p.fillVolume), y: this._convertToInches(p.fillHeight)});
          }
          // finally store the max values 
          vals.push({x: this._convertToLiters(limitVolume), y: this._convertToInches(limitHeight)});
          
          // Add the line
          let lines = chart.select('.working-volume.line').data([vals]);
          lines.enter()
              .merge(lines)
                  .attr("d", line);  
          lines.exit().remove();
                          
          // Add the area
          let areas = chart.select('.working-volume.area').data([vals]);
          areas.enter()
              .merge(areas)
                  .attr("d", area);  
          areas.exit().remove();
      }
      _updateVolumePoints(pan, volumeSelected, chart, xScale, yScale) {
          if(!pan || !volumeSelected || !chart || !xScale || !yScale) {
              return;
          }
          
          let vals = [];
          
          switch(volumeSelected) {
            case 'min': 
              vals.push({x: this._convertToLiters(pan.minFillVolume), y: this._convertToInches(pan.minFillHeight)});
              break;
            case 'max':
              vals.push({x: this._convertToLiters(pan.maxFillVolume), y: this._convertToInches(pan.maxFillHeight)});
              break;
            case 'brim':
              vals.push({x: this._convertToLiters(pan.brimVolume), y: this._convertToInches(pan.brimHeight)});
              break;
            case 'range':
              vals.push({x: this._convertToLiters(pan.minFillVolume), y: this._convertToInches(pan.minFillHeight)});
              vals.push({x: this._convertToLiters(pan.maxFillVolume), y: this._convertToInches(pan.maxFillHeight)});
              break;
            default: 
              vals.push({x: 0, y: 0});
              break;
          }
          
          // Add the dots
          let circles = chart.select('.volume-circles').selectAll('circle').data(vals);
          
          circles.enter()
                  .append('circle')
                      .attr('r', 7)
                  .merge(circles)
                    .attr('cx', function(d) { return xScale(d.x);})
                    .attr('cy', function(d) { return yScale(d.y);});
          
          circles.exit().remove();
      }
      
      _convertToInches(val) {
          return val * 39.37;
      }
      _convertToLiters(val) {
          return (val / 0.001) ;
      }
      _convertToLitersString(val) {
          return this._convertToLiters(val).toFixed(1);
      }
    }

    window.customElements.define(VolumeSection.is, VolumeSection);
  </script>
</dom-module>