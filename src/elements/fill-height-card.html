<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/iron-selector/iron-selector.html">
<link rel="import" href="../redux-mixin.html">
<link rel="import" href="coating-pan-class.html">
<link rel="import" href="unit-input.html">
<link rel="import" href="d3-import.html">
<link rel="import" href="card-styles.html">
<link rel="import" href="chart-styles.html">

<dom-module id="fill-height-card">
  <template>
    <style include='card-styles'></style>
    
    <style include='chart-styles'></style>
    
    <svg id='chart'>
      <g class='chart'>
          <g class='x axis'></g>
          <g class='y axis'></g>
          <text class='x title'>Product Fill Height (inches)</text>
          <text class='y title'>Volume (liters)</text>
          <path class='total secondary area'></path>
          <path class='total secondary line'></path>
          <path class='height dotted secondary line'></path>
          <path class='primary area'></path>
          <path class='primary line'></path>
          <circle class='circle'></circle>
      </g>
  </svg>
    
    <iron-selector selected='{{volumeSelected}}' attr-for-selected='volume'>
            <unit-input 
                volume='min'
                value='[[pan.minFillHeight]]' 
                type='length'
                selected-units='{{lengthUnits}}' 
                no-input 
                title='Min Fill Height' 
                details='Baffle height or 70% of brim height.'>
            </unit-input>
            <unit-input 
                volume='max'
                value='[[pan.maxFillHeight]]' 
                type='length'
                selected-units='{{lengthUnits}}' 
                no-input 
                title='Max Fill Height' 
                details='1" from brim opening.'>
            </unit-input>
            <unit-input 
                volume='brim'
                value='[[pan.brimHeight]]' 
                type='length'
                selected-units='{{lengthUnits}}' 
                no-input 
                title='Brim Height' 
                details='The overfilled limit.'>
            </unit-input>
        </iron-selector>
    
  </template>

  <script>
    class FillHeightCard extends ReduxMixin(Polymer.Element) {
      static get is() { return 'fill-height-card'; }
      
      connectedCallback() {
          super.connectedCallback();
          window.addEventListener('resize', () => this._setChartDimensions());
          this._setChartDimensions();
      }
      
      _setChartDimensions() {
          if(!this.$.chart) {
              return;
          }
          
          window.requestAnimationFrame(() => {
              this.chartHeight = this.$.chart.clientHeight - this.margin.top - this.margin.bottom;
              this.chartWidth = this.$.chart.clientWidth - this.margin.left - this.margin.right;
          });
      }
      
      static get properties() {
        return {
          pan: {type: Object, statePath: 'pan'},
          volumeUnits: {type: String, value: "l"},
          lengthUnits: {type: String, value: 'in'},
          volumeSelected: {type: String, value: "max"},
          chart: {type: Object},
          margin: {type: Object, value: function() {
              return {top: 20, right: 20, bottom: 50, left: 50};
          }},
          chartHeight: {type: Number},
          chartWidth: {type: Number},
          xScale: {type: Object, computed: '_computeXScale(chartWidth, pan.brimHeight)'},
          yScale: {type: Object, computed: '_computeYScale(chartHeight, pan.brimVolume)'},
          d3Line: {type: Object, computed: '_computeD3Line(xScale, yScale)'},
          d3Area: {type: Object, computed: '_computeD3Area(xScale, yScale, chartHeight)'}
        };
      }
      
      _computeXScale(chartWidth, brim) {
          let max = this._convertToInches(brim) * 1.1;
          return d3.scaleLinear().range([0, chartWidth]).domain([0, max]).nice();
      }
      _computeYScale(chartHeight, brim) {
          let max = this._convertToLiters(brim) * 1.1;
          return d3.scaleLinear().range([chartHeight, 0]).domain([0, max]).nice();
      }
      _computeD3Line(xScale, yScale) {
          return d3.line()
              .x(function(d) { return xScale(d.x); })
              .y(function(d) { return yScale(d.y); })
              .curve(d3.curveNatural);
      }
      _computeD3Area(xScale, yScale, height) {
          return d3.area()
                   .x(function(d) { return xScale(d.x); })
                   .y0(height)
                   .y1(function(d) { return yScale(d.y); }); 
      }
      
      static get observers() {
          return [
              '_initChart(margin, chartHeight, chartWidth)',
              '_updateAxis(xScale, yScale, chart)',
              '_updateDashedLine(pan, chart, d3Line, d3Area)',
              '_updateHeightLine(pan, volumeSelected, chart, d3Line, d3Area)',
              '_updateSolidLine(pan, volumeSelected, chart, d3Line, d3Area)',
              '_updateVolumePoints(pan, volumeSelected, chart, xScale, yScale)',
          ];
      }
      
      _initChart(margin, height, width) {
          if(!margin || !height || !width) {
              return;
          }
          let chart = d3.select(this.$.chart)
                              .attr("width", width + margin.left + margin.right)
                              .attr("height", height + margin.top + margin.bottom)
                          .select(".chart")
                              .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                                          
          chart.select(".x.axis").attr("transform", "translate(0," + height + ")");
          chart.select(".x.title").attr("transform", "translate(" + (width/2) + " ," + (height + margin.top + 25) + ")");
          chart.select(".y.title").attr("y", 0 - margin.left).attr("x",0 - (height / 2)).attr("dy", "1em");      
          
          // set the chart object
          this.chart = chart;
      }
      _updateAxis(xScale, yScale, chart) {
          if(!xScale || !yScale || !chart) {
              return;
          }
          chart.select(".x.axis").call(d3.axisBottom(xScale));
          chart.select(".y.axis").call(d3.axisLeft(yScale));  
      }
      _updateDashedLine(pan, chart, line, area) {
          if(!pan || !chart || !line || !area) {
              return;
          }
          
          // create a new coating pan object to make changes to
          let p = Object.assign(new CoatingPan(), pan);
          
          // initiate an empty array to store values in for loop
          let vals = [];
          let step = pan.brimVolume / 25;
          
          // loop through different volumes and store the volume and height values
          for(var i=0; i < pan.brimVolume; i = i + step) {
              p.fillVolume = i;
              vals.push({y: this._convertToLiters(p.fillVolume), x: this._convertToInches(p.fillHeight)});
          }
          // finally store the max values 
          vals.push({y: this._convertToLiters(pan.brimVolume), x: this._convertToInches(pan.brimHeight)});
          
          // Add the line
          let lines = chart.select('.total.line').data([vals]);
          lines.enter()
              .merge(lines)
                  .attr("d", line);  
          lines.exit().remove();
                          
          // Add the area
          let areas = chart.select('.total.area').data([vals]);
          areas.enter()
              .merge(areas)
                  .attr("d", area);  
          areas.exit().remove();
      }
      _updateHeightLine(pan, volumeSelected, chart, line, area) {
          if(!pan || !volumeSelected || !chart || !line || !area) {
              return;
          }
          
          // initiate an empty array to store values in for loop
          let vals = [];
          
          switch(volumeSelected) {
            case 'min': 
              vals.push({y: 0, x: this._convertToInches(pan.minFillHeight)});
              vals.push({y: this._convertToLiters(pan.minFillVolume), x: this._convertToInches(pan.minFillHeight)});
              break;
            case 'max':
              vals.push({y: 0, x: this._convertToInches(pan.maxFillHeight)});
              vals.push({y: this._convertToLiters(pan.maxFillVolume), x: this._convertToInches(pan.maxFillHeight)});
              break;
            case 'brim':
              vals.push({y: 0, x: this._convertToInches(pan.brimHeight)});
              vals.push({y: this._convertToLiters(pan.brimVolume), x: this._convertToInches(pan.brimHeight)});
              break;
            default: 
              vals.push({y: 0, x: 0});
              break;
          }
          
          // Add the line
          let lines = chart.select('.height.line').data([vals]);
          lines.enter()
              .merge(lines)
                  .attr("d", line);  
          lines.exit().remove();
      }
      _updateSolidLine(pan, volumeSelected, chart, line, area) {
          if(!pan || !volumeSelected || !chart || !line || !area) {
              return;
          }
          
          // create a new coating pan object to make changes to
          let p = Object.assign(new CoatingPan(), pan);
          
          let limitVolume, limitHeight, limitLowVolume; 
          switch(volumeSelected) {
            case 'min': 
              limitVolume = pan.minFillVolume;
              limitHeight = pan.minFillHeight;
              limitLowVolume = 0;
              break;
            case 'max':
              limitVolume = pan.maxFillVolume;
              limitHeight = pan.maxFillHeight;
              limitLowVolume = 0;
              break;
            case 'brim':
              limitVolume = pan.brimVolume;
              limitHeight = pan.brimHeight;
              limitLowVolume = 0;
              break;
            case 'range':
              limitVolume = pan.maxFillVolume;
              limitHeight = pan.maxFillHeight;
              limitLowVolume = pan.minFillVolume;
              break;
            default: 
              limitLowVolume = 0;
              limitVolume = 0;
              limitHeight = 0;
              break;
          }
          
          // initiate an empty array to store values in for loop
          let vals = [];
          let step = (limitVolume - limitLowVolume) / 25;
          
          // loop through different volumes and store the volume and height values
          for(var i=limitLowVolume; i < limitVolume; i = i + step) {
              p.fillVolume = i;
              vals.push({y: this._convertToLiters(p.fillVolume), x: this._convertToInches(p.fillHeight)});
          }
          // finally store the max values 
          vals.push({y: this._convertToLiters(limitVolume), x: this._convertToInches(limitHeight)});
          
          // Add the line
          let lines = chart.select('.primary.line').data([vals]);
          lines.enter()
              .merge(lines)
                  .attr("d", line);  
          lines.exit().remove();
                          
          // Add the area
          let areas = chart.select('.primary.area').data([vals]);
          areas.enter()
              .merge(areas)
                  .attr("d", area);  
          areas.exit().remove();
      }
      _updateVolumePoints(pan, volumeSelected, chart, xScale, yScale) {
          if(!pan || !volumeSelected || !chart || !xScale || !yScale) {
              return;
          }
          
          let vals = [];
          
          switch(volumeSelected) {
            case 'min': 
              vals.push({y: this._convertToLiters(pan.minFillVolume), x: this._convertToInches(pan.minFillHeight)});
              break;
            case 'max':
              vals.push({y: this._convertToLiters(pan.maxFillVolume), x: this._convertToInches(pan.maxFillHeight)});
              break;
            case 'brim':
              vals.push({y: this._convertToLiters(pan.brimVolume), x: this._convertToInches(pan.brimHeight)});
              break;
            case 'range':
              vals.push({y: this._convertToLiters(pan.minFillVolume), x: this._convertToInches(pan.minFillHeight)});
              vals.push({y: this._convertToLiters(pan.maxFillVolume), x: this._convertToInches(pan.maxFillHeight)});
              break;
            default: 
              vals.push({y: 0, x: 0});
              break;
          }
          
          // Add the dots
          let circles = chart.select('.circle').data(vals);
          
          circles.enter()
                  .append('circle')
                      .attr('class', 'circle')
                  .merge(circles)
                    .attr('r', 7)
                    .attr('cx', function(d) { return xScale(d.x);})
                    .attr('cy', function(d) { return yScale(d.y);});
          
          circles.exit().remove();
      }
      
      _convertToInches(val) {
          return val * 39.37;
      }
      _convertToLiters(val) {
          return (val / 0.001) ;
      }
      _convertToLitersString(val) {
          return this._convertToLiters(val).toFixed(1);
      }
    }

    window.customElements.define(FillHeightCard.is, FillHeightCard);
  </script>
</dom-module>